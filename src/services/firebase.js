// src/services/firebase.js - CONFIGURACI√ìN MEJORADA PARA SINCRONIZACI√ìN BIDIRECCIONAL
import { initializeApp } from "firebase/app";
import { 
  getFirestore,
  enableNetwork,
  disableNetwork,
  connectFirestoreEmulator
} from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSyDHM-P0oVfUv_8vGNODDOaQi4PUfmwhMmE",
  authDomain: "chinese-flashcards-a12f8.firebaseapp.com",
  projectId: "chinese-flashcards-a12f8",
  storageBucket: "chinese-flashcards-a12f8.firebasestorage.app",
  messagingSenderId: "690764775481",
  appId: "1:690764775481:web:019ae3edd13cae27128de8",
  measurementId: "G-QBJY3QNWMV"
};

// Initialize Firebase - UNA SOLA VEZ
const app = initializeApp(firebaseConfig);

// Initialize Firestore con configuraci√≥n optimizada
const db = getFirestore(app);

// Estado de conexi√≥n mejorado
let connectionState = 'initializing';
let initializationPromise = null;
let connectionMonitorInterval = null;
let isEmulatorMode = false;

// Logging mejorado
const log = (message, data = null) => {
  const timestamp = new Date().toISOString();
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const device = isMobile ? 'Mobile' : 'Desktop';
  console.log(`[Firebase][${device}][${timestamp}] ${message}`, data || '');
};

// Funci√≥n de inicializaci√≥n mejorada
const initializeFirestoreConnection = async () => {
  if (initializationPromise) {
    log('‚è≥ Inicializaci√≥n ya en progreso...');
    return initializationPromise;
  }

  initializationPromise = (async () => {
    try {
      log('üî• Inicializando Firestore...');
      
      // Configurar emulador en desarrollo si est√° disponible
      if (process.env.NODE_ENV === 'development' && process.env.REACT_APP_USE_FIRESTORE_EMULATOR === 'true') {
        try {
          connectFirestoreEmulator(db, 'localhost', 8080);
          isEmulatorMode = true;
          log('üîß Conectado al emulador de Firestore');
        } catch (error) {
          log('‚ö†Ô∏è No se pudo conectar al emulador, usando producci√≥n');
        }
      }
      
      // Habilitar la red con reintentos
      await enableNetworkWithRetry();
      connectionState = 'online';
      
      log('‚úÖ Firestore inicializado correctamente', {
        emulator: isEmulatorMode,
        state: connectionState
      });
      
      return true;
    } catch (error) {
      log('‚ùå Error inicializando Firestore:', error);
      connectionState = 'offline';
      return false;
    }
  })();

  return initializationPromise;
};

// Funci√≥n para habilitar la red con reintentos
const enableNetworkWithRetry = async (maxRetries = 3) => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      log(`üåê Intento ${attempt}/${maxRetries} de habilitar red...`);
      await enableNetwork(db);
      return true;
    } catch (error) {
      log(`‚ùå Error en intento ${attempt}:`, error.message);
      if (attempt === maxRetries) {
        throw error;
      }
      // Esperar antes del siguiente intento
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
};

// Funci√≥n para verificar conexi√≥n mejorada con timeout personalizable
export const checkFirestoreConnection = async (timeoutMs = 5000) => {
  try {
    log('üîç Verificando conexi√≥n...');
    
    const { doc, getDoc } = await import('firebase/firestore');
    const testRef = doc(db, 'connection_test', 'ping');
    
    // Promise de timeout
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error(`Connection timeout after ${timeoutMs}ms`)), timeoutMs);
    });
    
    // Promise de prueba de conexi√≥n
    const testPromise = getDoc(testRef);
    
    await Promise.race([testPromise, timeoutPromise]);
    
    connectionState = 'online';
    log('‚úÖ Conexi√≥n verificada exitosamente');
    return true;
  } catch (error) {
    log('üì° Verificaci√≥n de conexi√≥n fall√≥:', error.message);
    connectionState = 'offline';
    return false;
  }
};

// Funci√≥n para ir offline con limpieza
export const goOffline = async () => {
  try {
    log('üì± Deshabilitando red...');
    await disableNetwork(db);
    connectionState = 'offline';
    log('‚úÖ Firestore offline');
    return true;
  } catch (error) {
    log('‚ùå Error al ir offline:', error);
    return false;
  }
};

// Funci√≥n para ir online con verificaci√≥n
export const goOnline = async () => {
  try {
    log('üåê Habilitando red...');
    await enableNetworkWithRetry();
    
    // Verificar que la conexi√≥n funciona realmente
    const isConnected = await checkFirestoreConnection();
    
    if (isConnected) {
      connectionState = 'online';
      log('‚úÖ Firestore online y verificado');
      
      // Disparar evento personalizado para notificar reconexi√≥n
      window.dispatchEvent(new CustomEvent('firestoreReconnected', {
        detail: { timestamp: new Date().toISOString() }
      }));
      
      return true;
    } else {
      connectionState = 'offline';
      log('‚ö†Ô∏è Red habilitada pero sin conectividad real');
      return false;
    }
  } catch (error) {
    log('‚ùå Error al ir online:', error);
    connectionState = 'offline';
    return false;
  }
};

// Obtener estado de conexi√≥n detallado
export const getConnectionState = () => {
  return {
    state: connectionState,
    emulator: isEmulatorMode,
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    online: navigator.onLine
  };
};

// Monitor de conexi√≥n inteligente
const startConnectionMonitor = () => {
  if (connectionMonitorInterval) {
    log('üîÑ Reiniciando monitor de conexi√≥n...');
    clearInterval(connectionMonitorInterval);
  }

  log('üëÅÔ∏è Iniciando monitor de conexi√≥n...');

  // Monitor principal cada 30 segundos
  connectionMonitorInterval = setInterval(async () => {
    if (connectionState === 'offline') {
      log('üîÑ Estado offline detectado, verificando reconexi√≥n...');
      const isOnline = await checkFirestoreConnection(3000); // Timeout m√°s corto para el monitor
      if (isOnline) {
        log('üéâ Reconexi√≥n detectada!');
        window.dispatchEvent(new CustomEvent('firestoreReconnected', {
          detail: { 
            timestamp: new Date().toISOString(),
            source: 'monitor'
          }
        }));
      }
    }
  }, 30000); // Cada 30 segundos

  // Escuchar eventos del navegador
  const handleBrowserOnline = async () => {
    log('üåê Evento online del navegador detectado');
    setTimeout(async () => {
      await goOnline();
    }, 1000); // Peque√±o delay para que la conexi√≥n se estabilice
  };

  const handleBrowserOffline = () => {
    log('üì° Evento offline del navegador detectado');
    connectionState = 'offline';
    window.dispatchEvent(new CustomEvent('firestoreDisconnected', {
      detail: { 
        timestamp: new Date().toISOString(),
        source: 'browser'
      }
    }));
  };

  // Escuchar cambios de visibilidad para verificar conexi√≥n al volver
  const handleVisibilityChange = async () => {
    if (document.visibilityState === 'visible' && connectionState === 'offline') {
      log('üëÅÔ∏è P√°gina visible nuevamente, verificando conexi√≥n...');
      setTimeout(async () => {
        await checkFirestoreConnection();
      }, 500);
    }
  };

  window.addEventListener('online', handleBrowserOnline);
  window.addEventListener('offline', handleBrowserOffline);
  document.addEventListener('visibilitychange', handleVisibilityChange);

  // Funci√≥n de limpieza
  return () => {
    log('üßπ Limpiando monitor de conexi√≥n...');
    if (connectionMonitorInterval) {
      clearInterval(connectionMonitorInterval);
      connectionMonitorInterval = null;
    }
    window.removeEventListener('online', handleBrowserOnline);
    window.removeEventListener('offline', handleBrowserOffline);
    document.removeEventListener('visibilitychange', handleVisibilityChange);
  };
};

// Funci√≥n de limpieza completa
export const cleanup = async () => {
  try {
    log('üßπ Iniciando limpieza completa de Firebase...');
    
    if (connectionMonitorInterval) {
      clearInterval(connectionMonitorInterval);
      connectionMonitorInterval = null;
    }
    
    await disableNetwork(db);
    connectionState = 'offline';
    
    log('‚úÖ Limpieza completa de Firebase completada');
  } catch (error) {
    log('‚ùå Error durante limpieza:', error);
  }
};

// Funci√≥n para reinicializar la conexi√≥n
const reinitializeConnection = async () => {
  try {
    log('üîÑ Reinicializando conexi√≥n...');
    
    // Limpiar estado anterior
    if (connectionMonitorInterval) {
      clearInterval(connectionMonitorInterval);
    }
    
    // Reinicializar
    initializationPromise = null;
    const result = await initializeFirestoreConnection();
    
    if (result) {
      cleanupFunction = startConnectionMonitor();
    }
    
    return result;
  } catch (error) {
    log('‚ùå Error reinicializando:', error);
    return false;
  }
};

// Funci√≥n para obtener m√©tricas de rendimiento
const getPerformanceMetrics = () => {
  return {
    connectionState,
    isEmulatorMode,
    initializationTime: initializationPromise ? 'completed' : 'pending',
    monitorActive: !!connectionMonitorInterval,
    browserOnline: navigator.onLine,
    timestamp: new Date().toISOString()
  };
};

// Inicializaci√≥n autom√°tica mejorada
let cleanupFunction = null;

const initialize = async () => {
  try {
    log('üöÄ Iniciando inicializaci√≥n autom√°tica...');
    
    const success = await initializeFirestoreConnection();
    
    if (success) {
      cleanupFunction = startConnectionMonitor();
      log('üìã Inicializaci√≥n completada:', {
        project: firebaseConfig.projectId,
        state: connectionState,
        emulator: isEmulatorMode
      });
    } else {
      log('‚ö†Ô∏è Inicializaci√≥n fall√≥, reintentando en 5 segundos...');
      setTimeout(initialize, 5000);
    }
  } catch (error) {
    log('‚ùå Error en inicializaci√≥n autom√°tica:', error);
    setTimeout(initialize, 5000);
  }
};

// Inicializar una sola vez al cargar el m√≥dulo
initialize().catch(error => {
  log('‚ùå Error cr√≠tico en inicializaci√≥n:', error);
});

// Manejar beforeunload para limpieza
window.addEventListener('beforeunload', () => {
  if (cleanupFunction) {
    cleanupFunction();
  }
});

// Exportar instancias y funciones principales
export { db, app };
export default db;

// Exportar funci√≥n de limpieza total
export const cleanupAll = () => {
  log('üßπ Ejecutando limpieza total...');
  if (cleanupFunction) {
    cleanupFunction();
    cleanupFunction = null;
  }
  return cleanup();
};

// Exportar funciones de utilidad (nombres √∫nicos)
export const reinitialize = reinitializeConnection;
export { getPerformanceMetrics, initializeFirestoreConnection };